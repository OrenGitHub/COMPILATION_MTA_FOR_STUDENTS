%%%%%%%%%%%%%%%%%%
% DOCUMENT CLASS %
%%%%%%%%%%%%%%%%%%
\documentclass{article}

%%%%%%%%%%%%
% PACKAGES %
%%%%%%%%%%%%
\usepackage{hyperref}

%%%%%%%%%%%%%%%%%%
% BEGIN DOCUMENT %
%%%%%%%%%%%%%%%%%%
\begin{document}

%%%%%%%%%
% TITLE %
%%%%%%%%%
\title{Exercise 3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% AUTHOR = COURSE NAME HERE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\author{Compilation 0368:3133}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DATE = SUBMISSION DATE HERE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\date{Due 27/12/2017}

%%%%%%%%%
% TITLE %
%%%%%%%%%
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION :: Introduction %
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
We continue our journey of building a compiler
for the invented object oriented language RioMare.
Remember that the entire specification of RioMare appears
inside the relevant folder of the course website.
In order to make this document self contained,
all the information needed to complete the third exercise is brought here again.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION :: Programming Assignment %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Programming Assignment}
The third exercise implements a semantic analyzer that
recursively scans the AST produced by
\href{http://www2.cs.tum.edu/projects/cup/}{CUP},
and checks if it contains any semantic errors.
The input for the semantic analyzer is a (single) text file containing a RioMare program,
and the output is a (single) text file indicating whether the input program
is semantically valid or not.
In addition to that, whenever the input program is valid semantically,
the semantic analyzer will add meta data to the abstract syntax tree,
which is needed for later phases (code generation and optimization).
The added meta data content will not be checked in exercises $3$,
but the best time to design and implement this addition is
exercise $3$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION :: RioMare Semantics %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The RioMare Semantics}
This section describes the semantics of RioMare,
and provides a multitude of legal and illegal example programs.
%%%%%%%%%%%%%%%%%%%%%%%%
% SUB-SECTION :: Types %
%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Types}
The RioMare programming language defines a single native type: integer.
In addition, it is possible to define a class by specifying its data members and methods.
Note, that defining classes is only possible in the uppermost (global) scope.
The exact details follow.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUB-SUB-SECTION :: Classes %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Classes}
\label{subsubsection_Classes}
Classes contain data members and methods,
and can only be defined in the uppermost (global) scope.
Class names must be unique, and different than any previously defined
function name or (global) variable name.
Classes can refer to/extend only previously defined classes,
to ensure that the class hierarchy has a tree structure.
However, a method \verb"M1" \textit{can} refer to a method \verb"M2",
even if \verb"M2" is defined \textit{after} \verb"M1" in the class.
Following the same concept, a method \verb"M" \textit{can} refer to
a data member \verb"d", even if \verb"d" is defined \textit{after} \verb"M" in the class.
Table \ref{Table_Code_Examples_Use_Before_Def} summarizes these facts.
\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $1$ & \verb"CLASS Son EXTENDS Father { int bar; }" & ERROR \\
     & \verb"CLASS Father"                          &       \\
     & \verb"{"                                     &       \\
     & ~ ~ ~ ~\verb"void foo() { PrintInt(8); }"    &       \\
     & \verb"}"                                     &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $2$ & \verb"CLASS Edge"                         &       \\
     & \verb"{"                                  &       \\
     & ~ ~ ~ ~\verb"Vertex u;"                   & ERROR \\
     & ~ ~ ~ ~\verb"Vertex v;"                   &       \\
     & \verb"}"                                  &       \\
     & \verb"CLASS Vertex { int weight; }"       &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $3$ & \verb"CLASS UseBeforeDef {"                    &    \\
     & ~ ~ ~ ~\verb"void foo() { bar(8); }"           & OK \\
     & ~ ~ ~ ~\verb"void bar(int i) { PrintInt(i); }" &    \\
     & \verb"}"                                       &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $4$ & \verb"CLASS UseBeforeDef {"               &    \\
     & ~ ~ ~ ~\verb"void foo() { PrintInt(i); }" & OK \\
     & ~ ~ ~ ~\verb"int i;"                      &    \\
     & \verb"}"                                  &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $5$ & \verb"CLASS Tree {"                                    &    \\
     & ~ ~ ~ ~\verb"int sum()"                                &    \\
     & ~ ~ ~ ~\verb"{"                                        &    \\
     & ~ ~ ~ ~ ~ ~ ~ ~\verb"return i+left.sum()+right.sum();" &    \\
     & ~ ~ ~ ~\verb"}"                                        & OK \\
     & ~ ~ ~ ~\verb"int i := 0;"                              &    \\
     & ~ ~ ~ ~\verb"Tree left := NIL;"                        &    \\
     & ~ ~ ~ ~\verb"Tree right := NIL;"                       &    \\
     & \verb"}"                                               &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
\end{tabular}
\caption{Referring to classes, methods and data members
\label{Table_Code_Examples_Use_Before_Def}}
\end{table}
\newpage
\paragraph{Methods overloading} is \textit{illegal} in RioMare,
with the obvious exception of overriding a method in a derived class.
Similarly, it is illegal to define a method with the same name of
a previously defined variable in the class.
Furthermore, and in contrast to most programming languages,
we forbid that methods names will be the same as current/previously defined class names.
Table \ref{Table_Code_Examples_Overload_Override} summarizes these facts.
\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $1$ & \verb"CLASS Father {"                     &       \\
     & ~ ~ ~ ~\verb"int foo() { return 8; }"     &       \\
     & \verb"}"                                  &       \\
     & \verb"CLASS Son EXTENDS Father {"         &       \\
     & ~ ~ ~ ~\verb"void foo() { PrintInt(8); }" & ERROR \\
     & \verb"}"                                  &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $2$ & \verb"CLASS Father {"                      &    \\
     & ~ ~ ~ ~\verb"int foo(int i) { return 8; }" &    \\
     & \verb"}"                                   & OK \\
     & \verb"CLASS Son EXTENDS Father {"          &    \\
     & ~ ~ ~ ~\verb"int foo(int j) { return j; }" &    \\
     & \verb"}"                                   &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $3$ & \verb"CLASS IllegalSameName"                   &       \\
     & \verb"{"                                       &       \\
     & ~ ~ ~ ~\verb"void foo() { PrintInt(8); }"      &       \\
     & ~ ~ ~ ~\verb"void foo(int i) { PrintInt(i); }" & ERROR \\
     & \verb"}"                                       &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $4$ & \verb"CLASS Father {"                      &       \\
     & ~ ~ ~ ~\verb"int foo;"                     &       \\
     & ~ ~ ~ ~\verb"Father foo() { return NIL; }" & ERROR \\
     & \verb"}"                                   &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
\end{tabular}
\caption{Method overloading is illegal in RioMare.
\label{Table_Code_Examples_Overload_Override}}
\end{table}
\newpage
\paragraph{Variable Shadowing} is \textit{illegal} in RioMare.
That is, defining a class data member with a name that already exists in
the super class.
Similarly, it is illegal to define a data member with the same name of
a previously defined method in the class.
Furthermore, and in contrast to most programming languages,
we forbid that data member names will be the same as current/previously defined class names.
Table \ref{Table_Code_Examples_Variable_Shadowing} summarizes these facts.
\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $1$ & \verb"CLASS Father {"             &       \\
     & ~ ~ ~ ~\verb"int foo;"            &       \\
     & \verb"}"                          &       \\
     & \verb"CLASS Son EXTENDS Father {" &       \\
     & ~ ~ ~ ~\verb"Father foo;"         & ERROR \\
     & \verb"}"                          &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $2$ & \verb"CLASS Father {"                      &       \\
     & ~ ~ ~ ~\verb"Father foo() { return NIL; }" &       \\
     & ~ ~ ~ ~\verb"int foo;"                     & ERROR \\
     & \verb"}"                                   &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $3$ & \verb"CLASS Father {"                      &       \\
     & ~ ~ ~ ~\verb"int Father;"                  & ERROR \\
     & \verb"}"                                   &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
\end{tabular}
\caption{Variable shadowing is illegal in RioMare.
\label{Table_Code_Examples_Variable_Shadowing}}
\end{table}
\newpage
\paragraph{Inheritance} if class \verb"Son" is derived from class \verb"Father",
then any place in the program that semantically allows an expression of type \verb"Father",
should semantically allow an expression of type \verb"Son".
For example,
\begin{table}[h]
\centering
\begin{tabular}{ | l  | l | }
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\verb"CLASS Father { int i; }"               &    \\
\verb"CLASS Son EXTENDS Father { int j; }"   & OK \\
\verb"void foo(Father f) { PrintInt(f.i); }" &    \\
\verb"void main(){ foo(NEW Son); }"          &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
\end{tabular}
\caption{new Son is a semantically valid input for foo.
\label{Table_Code_Examples_Son_Class_Instead_Of_Father_Class}}
\end{table}
\paragraph{nil expressions} any place in the program that
semantically allows an expression of type class,
should semantically allow \verb"nil" instead.
For instance,
\begin{table}[h]
\centering
\begin{tabular}{ | l | l | }
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\verb"CLASS Father { int i; }"              &    \\
\verb"void foo(Father f){ PrintInt(f.i); }" & OK \\
\verb"void main(){ foo(nil); }"            &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
\end{tabular}
\caption{nil sent instead of a (Father) class is semantically allowed.
\label{Table_Code_Examples_nil_Instead_Of_Any_Class}}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUB-SECTION :: Assignments %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Assignments}
\label{subsection_Assignments}
Assigning an expression to a variable is clearly legal whenever the two have the same type.
In addition, following the concept in \ref{subsubsection_Classes},
if class \verb"Son" is derived from class \verb"Father",
then a variable of type \verb"Father" can be assigned an expression
of type \verb"Son".
Furthermore, following the concept in \ref{subsubsection_Classes},
assigning \verb"nil" to class variables is legal.
In contrast to that, assigning \verb"nil" to int variables is \textit{illegal}.
To avoid an overly complex semantics,
we will enforce a strict policy of initializing data members inside classes:
a declared data member inside a class can be initialized \textit{only with a constant value}
(that matches its type). Specifically, only constant integers and \verb"nil"
can be used, and even a simple expression like $5+6$ is forbidden.
Table \ref{Table_Code_Examples_Assignments} summarizes these facts.
\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $1$ & \verb"CLASS Father { int i; }"             & OK \\
     & \verb"Father f := nil;"                   &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $2$ & \verb"CLASS Father { int i; }"             &    \\
     & \verb"CLASS Son EXTENDS Father { int j; }" & OK \\
     & \verb"Father f := NEW Son;"                &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $3$ & \verb"CLASS Father { int i; }"                  & OK \\
     & \verb"CLASS Son EXTENDS Father { int j := 8; }" &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $4$ & \verb"CLASS Father { int i := 9; }"             &       \\
     & \verb"CLASS Son EXTENDS Father { int j := i; }" & ERROR \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $5$ & \verb"CLASS Father { int foo() { return 90; } }"    &       \\
     & \verb"CLASS Son EXTENDS Father { int j := foo(); }" & ERROR \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $6$ & \verb"CLASS IntList"                       &       \\
     & \verb"{"                                   &       \\
     & ~ ~ ~ ~\verb"int head := -1;"              &       \\
     & ~ ~ ~ ~\verb"IntList tail := NEW IntList;" & ERROR \\
     & \verb"}"                                   &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $7$ & \verb"CLASS IntList"                               &    \\
     & \verb"{"                                           &    \\
     & ~ ~ ~ ~\verb"void Init() { tail := NEW IntList; }" & OK \\
     & ~ ~ ~ ~\verb"int head;"                            &    \\
     & ~ ~ ~ ~\verb"IntList tail;"                        &    \\
     & \verb"}"                                           &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
\end{tabular}
\caption{Assignments.
\label{Table_Code_Examples_Assignments}}
\end{table}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUB-SECTION :: If and While Statements %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{If and While Statements}
\label{subsection_If_And_While_Statements}
The type of the condition inside if and while statements is the primitive type int.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUB-SECTION :: Return Statements %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Return Statements}
\label{subsection_Return_Statements}
According to the syntax of RioMare, return statements can only be found inside functions.
Since functions can \textit{not} be nested,
it follows that a return statement belongs to \textit{exactly one} function.
when a function \verb"foo" is declared to have a \verb"void" return type,
then all of its return statements must be \textit{empty} (\verb"return;").
In contrast, when a function \verb"bar" has a non void return type \verb"T",
then a return statement inside \verb"bar" must be \textit{non empty},
and the type of the returned expression must match \verb"T".

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUB-SECTION :: Equality Testing %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Equality Testing}
\label{subsection_Equality_Testing}
Testing equality between two expressions is legal whenever the two have the same type.
In addition, following the same reason in \ref{subsection_Assignments},
if class \verb"Son" is derived from class \verb"Father",
then an expression  of type \verb"Father" can be
tested for equality with an expression of type \verb"Son".
Furthermore, any class variable can be tested for equality with \verb"nil".
The resulting type of a semantically valid comparison is the primitive type int.
Table \ref{Table_Code_Examples_Equality_Testing} summarizes these facts.
\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $1$ & \verb"CLASS Father { int i; int j; }" &    \\
     & \verb"int Check(Father f)"            &    \\
     & \verb"{"                              &    \\
     & ~ ~ ~ ~\verb"if (f = nil)"            &    \\
     & ~ ~ ~ ~\verb"{"                       & OK \\
     & ~ ~ ~ ~ ~ ~ ~ ~\verb"return 800;"     &    \\
     & ~ ~ ~ ~\verb"}"                       &    \\
     & ~ ~ ~ ~\verb"return 774;"             &    \\
     & \verb"}"                              &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $2$ & \verb"CLASS Father { int i; int j; }"     &    \\
     & \verb"CLASS Son EXTENDS Father {int m; }" &    \\
     & \verb"int foo(Father f, Son s)"           &    \\
     & \verb"{"                                  & OK \\
     & ~ ~ ~ ~\verb"if (f = s) { return 1; }"    &    \\
     & ~ ~ ~ ~\verb"return 0;"                   &    \\
     & \verb"}"                                  &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
\end{tabular}
\caption{Equality testing.
\label{Table_Code_Examples_Equality_Testing}}
\end{table}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUB-SECTION :: Binary Operations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Binary Operations}
\label{subsection_Binary_Operations}
Binary operations $(-,*,/,<,>)$ are performed only between integers.
The resulting type of a semantically valid binary operation is the primitive type int.
Table \ref{Table_Code_Examples_Binary_Operations} summarizes these facts.
\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $1$ & \verb"CLASS Father"                     &    \\
     & \verb"{"                                &    \\
     & ~ ~ ~ ~\verb"int foo() { return 8/0; }" & OK \\
     & \verb"}"                                &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $2$ & \verb"CLASS Father { Father f1; Father f2; }" &       \\
     & \verb"void foo(Father f)"                     &       \\
     & \verb"{"                                      &       \\
     & ~ ~ ~ ~\verb"f := f.f1 + f.f2;"               & ERROR \\
     & \verb"}"                                      &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $3$ & \verb"CLASS Father { int i1; int i2; }"       &    \\
     & \verb"void foo(Father f)"                     &    \\
     & \verb"{"                                      & OK \\
     & ~ ~ ~ ~\verb"int i := f.i1 < f.i2;"           &    \\
     & \verb"}"                                      &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $4$ & \verb"CLASS Father { int j; int k; }" &    \\
     & \verb"int foo(Father f)"              &    \\
     & \verb"{"                              & OK \\
     & ~ ~ ~ ~\verb"int i := 620;"           &    \\
     & ~ ~ ~ ~\verb"return i < f.j;"         &    \\
     & \verb"}"                              &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
\end{tabular}
\caption{Binary Operations.
\label{Table_Code_Examples_Binary_Operations}}
\end{table}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUB-SECTION :: Scope Rules %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Scope Rules}
\label{subsection_Scope_Rules}
\paragraph{RioMare} defines four kinds of scopes:
block scopes of if and while statements,
function scopes,
class scopes and
the outermost global scope.
When an identifier is being used at some point in the program,
its declaration is searched for in all of its enclosing scopes.
The search starts from the innermost scope, 
and ends at the outermost (global) scope.
\paragraph{Primitive Types (int and string)}
can not be used as class names, variable names and function names.
The same goes for the library function name PrintInt.
\paragraph{Global Functions names}
should be unique, and different than any previously defined class type name and global variable name.
Following the same reason in \ref{Table_Code_Examples_Use_Before_Def},
functions may only refer to previously defined types, variables and functions.
When a function is being called inside a class scope, the declaration
of a function with that name is searched first in its class scope.
If no such function is found, the search moves to the global scope,
and if the declaration is missing there too, a semantic error is issued.
Following the same reason, when a function is being called inside the global scope,
only the global scope is searched for its declaration.
\paragraph{Resolving} a variable identifier
follows the same principal, with the slight difference that variables can be declared
in all four kinds of scopes.
Table \ref{Table_Code_Examples_Scope_Rules} summarizes these facts.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUB-SECTION :: Library Functions %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Library Functions}
\label{subsection_Library_Functions}
RioMare defines a single library function: PrintInt.\\
The signatures of PrintInt is as follows:\\ \\
\verb"void PrintInt(int i)      { ... }"\\ 
\newpage
\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $1$ & \verb"int salary := 7800;"                            &    \\
     & \verb"void foo()"                                     &    \\
     & \verb"{"                                              & OK \\
     & ~ ~ ~ ~\verb"string salary := "``\verb"6950""\verb";" &    \\
     & \verb"}"                                              &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $2$ & \verb"int salary := 7800;"         &    \\
     & \verb"void foo(string salary)"     &    \\
     & \verb"{"                           & OK \\
     & ~ ~ ~ ~\verb"PrintString(salary);" &    \\
     & \verb"}"                           &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $3$ & \verb"void foo(string salary)"     &       \\
     & \verb"{"                           &       \\
     & ~ ~ ~ ~\verb"int salary := 7800;"  & ERROR \\
     & ~ ~ ~ ~\verb"PrintString(salary);" &       \\
     & \verb"}"                           &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $4$ & \verb"string myvar := "``\verb"80""\verb";" &    \\
     & \verb"CLASS Father"                         &    \\
     & \verb"{"                                    &    \\
     & ~ ~ ~ ~\verb"Father myvar := nil;"          &    \\
     & ~ ~ ~ ~\verb"void foo()"                    & OK \\
     & ~ ~ ~ ~\verb"{"                             &    \\
     & ~ ~ ~ ~ ~ ~ ~ ~\verb"int myvar := 100;"     &    \\
     & ~ ~ ~ ~ ~ ~ ~ ~\verb"PrintInt(myvar);"      &    \\
     & ~ ~ ~ ~\verb"}"                             &    \\
     & \verb"}"                                    &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 $5$ & \verb"int foo(string s) { return 800;}"    &    \\
     & \verb"CLASS Father"                        &    \\
     & \verb"{"                                   &    \\
     & ~ ~ ~ ~\verb"string foo(string s)"         &    \\
     & ~ ~ ~ ~\verb"{"                            &    \\
     & ~ ~ ~ ~ ~ ~ ~ ~\verb"return s;"            & OK \\
     & ~ ~ ~ ~\verb"}"                            &    \\
     & ~ ~ ~ ~\verb"void Print()"                 &    \\
     & ~ ~ ~ ~\verb"{"                            &    \\
     & ~ ~ ~ ~ ~ ~ ~ ~\verb"PrintString(foo("``\verb"Jerry""\verb"));"  & \\
     & ~ ~ ~ ~\verb"}"                            &    \\
     & \verb"}"                                   &    \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
\end{tabular}
\caption{Scope Rules.
\label{Table_Code_Examples_Scope_Rules}}
\end{table}
\newpage
\begin{table}[h]
\centering
\begin{tabular}{ l c l }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Program  & $::=$ & dec$^{+}$ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dec      & $::=$ & funcDec $|$ varDec $|$ classDec $|$ arrayDec \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
varDec   & $::=$ & ID ID $[$ ASSIGN exp $]$ ';' \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
funcDec  & $::=$ & ID ID $'('$ $[$ ID ID $[$ ',' ID ID $]^{*}$ $]$ $')'$ %%
                   $'\{'$ stmt   $[$ stmt $]^{*}$ $'\}'$                 \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classDec & $::=$ & CLASS ID $[$ EXTENDS ID $]$ $'\{'$ cField $[$ cField $]^{*}$ $'\}'$ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
arrayDec & $::=$ & ARRAY ID $=$ ID $'['$ $']'$ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
exp      & $::=$ & var                                                            \\
         & $::=$ & $'('$ exp $')'$                                                \\
         & $::=$ & exp BINOP exp                                                  \\
         & $::=$ & $[$ var '.' $]$ ID $'('$ $[$ exp $[$ ',' exp $]^{*}$ $]$ $')'$ \\
         & $::=$ & $['-']$ INT $|$ NIL $|$ STRING $|$ NEW ID $|$ NEW ID $'['$ exp $']'$ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
var      & $::=$ & ID                  \\
         & $::=$ & var '.' ID          \\
         & $::=$ & var $'['$ exp $']'$ \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
stmt     & $::=$ & varDec                                                             \\
         & $::=$ & var ASSIGN exp ';'                                                 \\
         & $::=$ & RETURN $[$ exp $]$ ';'                                             \\
         & $::=$ & IF $'('$ exp $')'$ $'\{'$ stmt $[$ stmt $]^{*}$ $'\}'$             \\
         & $::=$ & WHILE $'('$ exp $')'$ $'\{'$ stmt $[$ stmt $]^{*}$ $'\}'$          \\
         & $::=$ & $[$ var '.' $]$ ID $'('$ $[$ exp $[$ ',' exp $]^{*}$ $]$ $')'$ ';' \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
cField   & $::=$ & varDec $|$ funcDec \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
BINOP    & $::=$ & $+$ $|$ $-$ $|$ $*$ $|$ $/$ $|$ $<$ $|$ $>$ $|$ $=$ \\
INT      & $::=$ & $[1-9][0-9]^{*}$ $|$ $0$                            \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\
\end{tabular}
\caption{
Context free grammar for the RioMare programming language.
\label{Table_CFG_Of_RioMare}}
\end{table}
\begin{table}[h]
\centering
\begin{tabular}{ |c|c|l|l| }
\hline
Precedence & Operator & Description & Associativity \\
\hline
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
1          & $:=$            & assign         &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
2          & $=$             & equals         & left  \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
3          & $<,>$           &                & left  \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
4          & $+,-$           &                & left  \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
5          & $*,/$           &                & left  \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
6          & $[$             & array indexing &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
7          & $($             & function call  &       \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
8          & $.$     & field access   & left          \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hline
\end{tabular}
\caption{
Binary operators of RioMare along with their associativity and precedence.
$1$ stands for the lowest precedence, and $9$ for the highest.
\label{Table_Binary_Operators_Of_RioMare}}
\end{table}

%%%%%%%%%%%%%%%%%%%%
% SECTION :: Input %
%%%%%%%%%%%%%%%%%%%%
\section{Input}
The input for this exercise is a single text file, the input RioMare program.

%%%%%%%%%%%%%%%%%%%%%
% SECTION :: Output %
%%%%%%%%%%%%%%%%%%%%%
\section{Output}
The output is a \textit{single} text file that contains a \textit{single} word.
Either OK when the input program is correct semantically,
or otherwise ERROR(\textit{location}), where \textit{location}
is the line number of the \textit{first} error that was encountered.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION :: Submission Guidelines %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Submission Guidelines}
The skeleton code for this exercise resides (as usual)
in subdirectory EX3 of the course repository.
COMPILATION/EX3 should contain a makefile building your source files to a
runnable jar file called COMPILER (note the lack of the .jar suffix).
Feel free to use the makefile supplied in the course repository,
or write a new one if you want to. 
Before you submit, make sure that your exercise compiles and runs
on Ubuntu 14.04.5 LTS.
This is the formal running environment of the course.

\paragraph{Execution parameters}
compiler receives $2$ input file names:\\ \\
InputRioMareProgram.txt\\
OutputStatus.txt

\end{document}
